# Recursion & backtracking
找所有解很可能就要递归

回溯本质上是对树或图dfs找到解

时间复杂度：一般来说比较高，不同情况比较不好算，可以说上限
比如全排列是o(n*n!)
why?




**与动态规划的区别**
- 共同点
用于求解多阶段决策问题。多阶段决策问题即：
1. 求解一个问题分为很多步骤（阶段）；
2. 每一个步骤（阶段）可以有多种选择。

- 不同点
动态规划只需要求我们评估最优解是多少，最优解对应的具体解是什么并不要求。因此很适合应用于评估一个方案的效果；
回溯算法可以搜索得到所有的方案（当然包括最优解），但是本质上它是一种遍历算法，时间复杂度很高。


## tail recursion
拆解后子问题只有一个的递归，可以写成循环interation
递归比循环慢，因为要压栈，弹栈

## 模板
### 返回值类型
- primitive type： 返回值return，type, 比较复杂也可以用全局变量记录
- reference type： 作为参数传递，void
当这个参数是所有题解公用的，可以直接传递，比如解空间results
如果这个参数在每个解中是独立的，需要传递的是这个参数的复制，不然会改变这个参数原来指向的对象，比如path

### base case
要考虑停止条件的优先级

### recursion rule
访问的点不要重复，out of memory

## 思路
### 一维
- 一个一个看选还是不选
- 每一个位置选谁
- 选择前几个，[index, i+1]

### 二维
双重循环选择起始点


## Maze解题思路

为简化，一次走一格
抉择有4个：上下左右

1. recursion rule
往上下左右四个方向走一格后，有一个返回true就可以

2. base case
- 走不下去的情况：遇到墙，或者出界
- 到达终点：坐标和终点坐标一致
- 避免走到走过的格子：标记走过的点，把走过的'.'换成'x'

为什么不会影响其他抉择

如果这个点走过但返回的是false，那么我们也不希望其他抉择再走到这个点了，所以标记为x，相当于剪枝

把判断走不下去的情况放在for循环里，如果是走不下去的，那就跳过，不用做递归了

注意二位数组的坐标，竖轴是第一维度，横轴是第二维度

有抉择时的路径
1. 之前的路径path作为递归函数的参数
2. 在base case也就是终止条件时，打印path
3. 在recursion时传入的参数，就是path + 这个抉择走的路径（并没有改变path，对于其他抉择无影响）

没有抉择时的路径
不需要参数，直接打印（暂时感觉是这样，因为一条路走到黑，还不确定）

当抉择很多的时候，每个抉择的路径占用空间大
base case
停止条件，有返回true的，也有返回false的









有重复元素，排序后重复元素相邻

- Combination

每层元素递减，对同一层上的重复元素剪枝

返回条件：遍历到选择列表最后一个元素

​			   或者回溯到上一层后返回

遍历：每轮都从选择列表i+1开始（前一个元素的后面）

剪枝：同一层重复元素

​		同一层：i > index

​		重复：nums[i] == nums[i-1] 

- permutation

每层都是所有元素，对同一层上的重复元素剪枝

返回条件：遍历到选择列表最后一个元素

遍历：每轮都从选择列表i=0开始

剪枝：同一层重复元素或者用过的元素

​		同一层：i > 0 && !used[i-1]

​		重复：nums[i] == nums[i-1] 

   	 用过：used[i]



combine每轮都从剩下的元素中选，不用考虑是否用过；permute每轮要从所有元素中选，所以要考虑是否用过



## 什么时候使用 used 数组，什么时候使用 index 变量?

- 排列问题，讲究顺序（即 [2, 2, 3] 与 [2, 3, 2] 视为不同列表时），需要记录哪些数字已经使用过，此时用 used 数组；有重复元素很可能用used区分一下

- 组合问题，不讲究顺序（即 [2, 2, 3] 与 [2, 3, 2] 视为相同列表时），需要按照某种顺序搜索，此时使用 index 变量。
解空间里某些解顺序不一样，如果算作一种就要去重，可以在放到path里的时候就把当前index前面的去掉，直接从index往后看

## path添加和移除

添加到path和从path中移除要在同一层递归中完成，如果添加在判断是否加入解空间以前，就要在加入解空间后移除path中最后一个元素，fuck好像这也不一定对，我也不知道，还是通过验证搞吧

还是需要具体情况具体分析，根据所选择的path类型看，比如char[]就不需要移除，后续对char[index]的赋值就相当于移除了，但如果用的是字符串或者list就需要移除

还有移除要写在哪，比如最后return前要不要移除，就要看操作的流程，能不能走到移除的最后一步

我感觉我写的可能只有我能看懂吧【手动捂脸】
还是需要多做题体悟


## v-practice

0-1 knapsack
maze
Knapsack
0-1 knapsack2
Permutation
Combination
Lucky Numbers
Letter Combinations of a Phone Number
Subsets
N-Queens
Palindrome Partitioning
Subsets II
Sudoku Solver
Restore IP Address
Word Search
Lettercase Permutation

## 练习
下面提供一些我做过的「回溯」算法的问题，以便大家学习和理解「回溯」算法。

### 题型一：排列、组合、子集相关问题

提示：这部分练习可以帮助我们熟悉「回溯算法」的一些概念和通用的解题思路。解题的步骤是：先画图，再编码。去思考可以剪枝的条件， 为什么有的时候用 used 数组，有的时候设置搜索起点 begin 变量，理解状态变量设计的想法。

46. 全排列（中等）

47. 全排列 II（中等）：思考为什么造成了重复，如何在搜索之前就判断这一支会产生重复；

48. 组合总和（中等）

49. 组合总和 II（中等）

50. 组合（中等）

51. 子集（中等）

52. 子集 II（中等）：剪枝技巧同 47 题、39 题、40 题；

53. 第 k 个排列（中等）：利用了剪枝的思想，减去了大量枝叶，直接来到需要的叶子结点；

54. 复原 IP 地址（中等）

    

    ### 题型二：Flood Fill

    提示：Flood 是「洪水」的意思，Flood Fill 直译是「泛洪填充」的意思，体现了洪水能够从一点开始，迅速填满当前位置附近的地势低的区域。类似的应用还有：PS 软件中的「点一下把这一片区域的颜色都替换掉」，扫雷游戏「点一下打开一大片没有雷的区域」。

下面这几个问题，思想不难，但是初学的时候代码很不容易写对，并且也很难调试。我们的建议是多写几遍，忘记了就再写一次，参考规范的编写实现（设置 visited 数组，设置方向数组，抽取私有方法），把代码写对。

733. 图像渲染（Flood Fill，中等）
200. 岛屿数量（中等）
130. 被围绕的区域（中等）
79. 单词搜索（中等）
说明：以上问题都不建议修改输入数据，设置 visited 数组是标准的做法。可能会遇到参数很多，是不是都可以写成成员变量的问题，面试中拿不准的记得问一下面试官

### 题型三：字符串中的回溯问题
提示：字符串的问题的特殊之处在于，字符串的拼接生成新对象，因此在这一类问题上没有显示「回溯」的过程，但是如果使用 StringBuilder 拼接字符串就另当别论。
在这里把它们单独作为一个题型，是希望朋友们能够注意到这个非常细节的地方。

17. 电话号码的字母组合（中等），题解；

18. 字母大小写全排列（中等）；

19. 括号生成（中等） ：这道题广度优先遍历也很好写，可以通过这个问题理解一下为什么回溯算法都是深度优先遍历，并且都用递归来写。

    

    

    ### 题型四：游戏问题
    回溯算法是早期简单的人工智能，有些教程把回溯叫做暴力搜索，但回溯没有那么暴力，回溯是有方向地搜索。「力扣」上有一些简单的游戏类问题，解决它们有一定的难度，大家可以尝试一下。

20. N 皇后（困难）：其实就是全排列问题，注意设计清楚状态变量，在遍历的时候需要记住一些信息，空间换时间；

21. 解数独（困难）：思路同「N 皇后问题」；

22. 祖玛游戏（困难）

23. 扫雷游戏（困难）
    （欢迎大家补充。）

作者：liweiwei1419
链接：https://leetcode-cn.com/problems/permutations/solution/hui-su-suan-fa-python-dai-ma-java-dai-ma-by-liweiw/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。